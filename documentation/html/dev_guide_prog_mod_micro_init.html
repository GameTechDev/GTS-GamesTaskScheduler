<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Games Task Scheduler (GTS): Micro-scheduler Initialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Games Task Scheduler (GTS)
   </div>
   <div id="projectbrief">A multi-processor scheduling framework for games engines</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dev_guide_prog_mod_micro_init.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Micro-scheduler Initialization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section covers extracting platform topology, the ID system, worker pools, and micro-schedulers.</p>
<h1><a class="anchor" id="autotoc_md62"></a>
Topology</h1>
<p>Platform topology defines how the OS organizes processors available to the developer.</p>
<h2><a class="anchor" id="autotoc_md63"></a>
Terminology</h2>
<p>GTS abstracts topology by:</p>
<ul>
<li><b>Processor</b>: a HW thread (<em>or logical processor</em>) on a Core.</li>
<li><b>Core</b>: a set of 1 or more processors.</li>
<li><b>Socket</b>: a physical piece of compute hardware.</li>
<li><b>NUMA Node</b>: a set of Cores and caches are close to one another.</li>
<li><b>Group</b>: a set of Cores, Sockets, and NUMA Nodes. On Windows, a group is limited to 64 processors.</li>
<li><b>Affinity</b>: a processor ID within a group. Affinity data can define which processor a SW thread will run on.</li>
</ul>
<h2><a class="anchor" id="autotoc_md64"></a>
API</h2>
<p>GTS makes this information available as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="structgts_1_1_system_topology.html">gts::SystemTopology</a> topology;</div>
<div class="line"><a class="code" href="classgts_1_1_thread.html#a91888c263187754ac797711ecbf334a7">gts::Thread::getSystemTopology</a>(topology);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md65"></a>
Groups</h3>
<p><a class="el" href="structgts_1_1_system_topology.html" title="A description of the system&#39;s processor topology.">gts::SystemTopology</a> is organized by groups. There can be 1 to N groups. Each group is organized by:</p>
<ul>
<li><b>Core.</b> A list of all cores with no association to each other.</li>
</ul>
<p><img src="Group.svg" alt="" style="pointer-events: none;" class="inline"/>   </p>
<ul>
<li><b>Socket.</b> A list of cores grouped by socket.</li>
</ul>
<p><img src="Socket.svg" alt="" style="pointer-events: none;" class="inline"/>   </p>
<ul>
<li><b>NUMA Node.</b> A list of cores group by NUMA node.</li>
</ul>
<p><img src="NumaNode.svg" alt="" style="pointer-events: none;" class="inline"/>   </p>
<h3><a class="anchor" id="autotoc_md66"></a>
Core</h3>
<p>Each core has the following information:</p>
<table style="width:100%">
<tr>
<td><img src="Core.svg" alt="" style="pointer-events: none;" vertical-align="top" class="inline"/> </td><td><ul vertical-align="top">
<li>
<b>Efficiency Class.</b> Defines the efficiency class of a Core. On a heterogeneous system, this is the relative performance of each Core, where higher efficiency class values have more performance. </li>
<li>
<b>Processor IDs.</b> Each processors ID/affinity. </li>
</ul>
</td></tr>
</table>
<h1><a class="anchor" id="autotoc_md67"></a>
ID system</h1>
<p>GTS employs a grouped ID system implemented with <a class="el" href="classgts_1_1_owned_id.html">OwnedId</a> to identify resouces and their subresources. An OwnedId consists of a <b>UID</b> that is split into two sub IDs an <b>Owner ID</b> and a <b>Local ID</b>.</p>
<table style="width:100%">
<tr>
<td><img src="OwnedID.svg" alt="" style="pointer-events: none;" vertical-align="top" class="inline"/> </td><td><ul vertical-align="top">
<li>
<b>Owner ID.</b> The resource ID. A globally unique ID [0, UINT16_MAX). These IDs are generated in strictly increasing order {0, 1, ..., UINT16_MAX-1} </li>
<li>
<b>Local ID.</b> The sub-resource ID. A locally unique ID [0, UINT16_MAX) relative to the resource. These IDs are generated in strictly increasing order {0, 1, ..., UINT16_MAX-1}. </li>
<li>
<b>UID.</b> A globally unique ID. </li>
</ul>
</td></tr>
</table>
<dl class="section warning"><dt>Warning</dt><dd>IDs will wrap if more than UINT16_MAX are generated.</dd></dl>
<h1><a class="anchor" id="autotoc_md68"></a>
Worker Pool</h1>
<p>A <a class="el" href="classgts_1_1_worker_pool.html">Worker Pool</a> is the fundumental <em><b>executor</b></em> of CPU work. It determines how SW <b>Worker</b> threads are mapped to a Groupâ€™s Processors.</p>
<h2><a class="anchor" id="autotoc_md69"></a>
Terminology</h2>
<ul>
<li><b>Worker:</b> A wrapper around a SW thread generated by the Worker Pool.</li>
<li><b>Worker ID:</b> A OwnedId of a Worker, where the Owner ID is the ID of the Worker Pool and the Local ID is the ID of the Worker.</li>
<li><b>Master:</b> The Worker associated with the calling thread that creates the Worker Pool. <em>The Worker Pool does not own this thread.</em> It always has a local ID of 0.</li>
</ul>
<p><img src="WorkerPoolMapping_IDs.svg" alt="" style="pointer-events: none;" class="inline" title="Figure 1: A simple Worker Pool mapping."/>   </p>
<dl class="section note"><dt>Note</dt><dd>GTS has no limit on the number of created Worker Pools, which enables the developer to divide up the compute resources to meet their needs.</dd></dl>
<h2><a class="anchor" id="autotoc_md70"></a>
Initialization</h2>
<p>A Worker Pool can be initialized three ways: default, by explicit thread count, and by description structure.</p>
<h3><a class="anchor" id="autotoc_md71"></a>
Default</h3>
<p>By default, a Worker Pool is initialized to contain the same number of SW threads as the system has HW thread.</p>
<div class="fragment"><div class="line"><a class="code" href="classgts_1_1_worker_pool.html">gts::WorkerPool</a> workerPool;</div>
<div class="line">workerPool.<a class="code" href="classgts_1_1_worker_pool.html#a0a210a25fa82f85cab05a28552b6fdbf">initialize</a>(<span class="comment">/* equivalent to gts::Thread::getHardwareThreadCount() *);</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md72"></a>
Explicit Thread Count</h3>
<p>The Worker Pool's SW thread count can also be initialized explicitly. The value can be more or less than the number of HW threads.</p>
<div class="fragment"><div class="line"><a class="code" href="classgts_1_1_worker_pool.html">gts::WorkerPool</a> workerPool;</div>
<div class="line">workerPool.<a class="code" href="classgts_1_1_worker_pool.html#a0a210a25fa82f85cab05a28552b6fdbf">initialize</a>(<a class="code" href="classgts_1_1_thread.html#a62e240cb86d364cb0c3bc941917479df">gts::Thread::getHardwareThreadCount</a>() - 2);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md73"></a>
Description Structure</h3>
<p>The Worker Pool can further be initialized explicitly with a <a class="el" href="structgts_1_1_worker_pool_desc.html">description structure</a>, providing control over each SW thread. The description structure specifies:</p>
<ul>
<li><b>Visitor</b> The caller can provide a <a class="el" href="structgts_1_1_worker_pool_visitor.html">WorkerPoolVisitor</a> to hook various points in the WorkerPools lifetime.</li>
<li><b>Thread Local Storage Redirection</b> The caller can provide getters and setters to their own TLS, useful for defining TLS in a different address space like cross DLL boundaries.</li>
<li><b>Task Caching</b> Workers will cache Tasks below a specified threshold. The caller can set this threshold via <a class="el" href="structgts_1_1_worker_pool_desc.html#a6ddc0570ed13670518c3a7ccce832feb" title="The maximum size of Tasks that are cached and reused. Sizes larger than this will be allocated from t...">gts::WorkerPoolDesc.cachableTaskSize</a>. All Tasks below this size will have their size clamped to it. The caller can also precache Tasks during initialization via <a class="el" href="structgts_1_1_worker_pool_desc.html#a2f260a1f805f95d7adceda5b739cebf8" title="The number of Tasks to create and cache per Worker during initialization.">gts::WorkerPoolDesc.initialTaskCountPerWorker</a>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The index of each <a class="el" href="structgts_1_1_worker_thread_desc.html" title="The description of a worker Thread.">gts::WorkerThreadDesc</a> pushed into <a class="el" href="structgts_1_1_worker_pool_desc.html#a4f6290f534d1fd6567b8c74f56eadd4f" title="The description of each worker thread.">gts::WorkerPoolDesc::workerDescs</a> becomes the Local ID of the Worker. This means the first element is always the Master Thread's description.</dd>
<dd>
Since the Worker Pool does not own the Master Thread, its description has no effect on the thread. It is merely a placeholder to keep the index mapping 1-1 with Local IDs.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Define the visitor.</span></div>
<div class="line"><span class="keyword">struct </span>MyVisitor : <span class="keyword">public</span> WorkerPoolVisitor</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onThreadStart(OwnedId workerId) <span class="keyword">final</span> { printf(<span class="stringliteral">&quot;Worker %d started&quot;</span>, workerId.localId()); }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onThreadExit(OwnedId workerId) <span class="keyword">final</span> { printf(<span class="stringliteral">&quot;Worker %d exited&quot;</span>, workerId.localId()); }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a visitor object. The object must</span></div>
<div class="line"><span class="comment">// stay alive for the lifetime of the WorkerPool.</span></div>
<div class="line">MyVisitor myVisitor;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structgts_1_1_worker_pool_desc.html">gts::WorkerPoolDesc</a> workerPoolDesc;</div>
<div class="line"> </div>
<div class="line">workerPoolDesc.<a class="code" href="structgts_1_1_worker_pool_desc.html#a6238c64768e4ba2da9c97c108127a15c">pVisitor</a> = &amp;myVisitor;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Specify that all Tasks below 512 bytes will be cached.</span></div>
<div class="line">workerPoolDesc.<a class="code" href="structgts_1_1_worker_pool_desc.html#a6ddc0570ed13670518c3a7ccce832feb">cachableTaskSize</a> = 512;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Specify that each Worker will pre-cache 2048 tasks.</span></div>
<div class="line">workerPoolDesc.<a class="code" href="structgts_1_1_worker_pool_desc.html#a2f260a1f805f95d7adceda5b739cebf8">initialTaskCountPerWorker</a> = 2048</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set a name to aid in debugging.</span></div>
<div class="line">sprintf(workerPoolDesc.<a class="code" href="structgts_1_1_worker_pool_desc.html#a7342f26da50f534d9341220566cd5021">name</a>, <span class="stringliteral">&quot;TheWorkerPool&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Name each Worker thread.</span></div>
<div class="line"><span class="keyword">const</span> uint32_t threadCount = gts::getHardwareThreadCount();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iThread = 0; iThread &lt; threadCount; ++iThread)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// NOTE: The order the WorkerThreadDesc are indexed into</span></div>
<div class="line">    <span class="comment">// WorkerThreadDesc::workerDescs is the Local ID of the</span></div>
<div class="line">    <span class="comment">// corresponding Worker. Worker thread #0 is always the thread </span></div>
<div class="line">    <span class="comment">// that the pool was created on and is considered the &quot;master&quot;</span></div>
<div class="line">    <span class="comment">// worker thread.</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structgts_1_1_worker_thread_desc.html">gts::WorkerThreadDesc</a> workerDesc;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set the thread&#39;s name.</span></div>
<div class="line">    sprintf(workerDesc.<a class="code" href="structgts_1_1_worker_thread_desc.html#a2ba1ba4aa956b3054dacb2c1e3bc8d0e">name</a>, <span class="stringliteral">&quot;Worker %d&quot;</span>, iThread);</div>
<div class="line"> </div>
<div class="line">    workerPoolDesc.<a class="code" href="structgts_1_1_worker_pool_desc.html#a4f6290f534d1fd6567b8c74f56eadd4f">workerDescs</a>.push_back(workerDesc);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The Master thread must be altered separately since the Worker</span></div>
<div class="line"><span class="comment">// Pool does not own it.</span></div>
<div class="line"><a class="code" href="structgts_1_1_this_thread.html#a94073c4c59603a010d35a5d19ead1a1e">gts::ThisThread::setName</a>(<span class="stringliteral">&quot;Master Thread&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a Worker Pool and init it with the description.</span></div>
<div class="line"><a class="code" href="classgts_1_1_worker_pool.html">gts::WorkerPool</a> workerPool;</div>
<div class="line">workerPool.<a class="code" href="classgts_1_1_worker_pool.html#a0a210a25fa82f85cab05a28552b6fdbf">initialize</a>(workerPoolDesc);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md74"></a>
Micro-scheduler</h1>
<p>A <a class="el" href="classgts_1_1_micro_scheduler.html">Micro-scheduler</a> defines the schuduling policy of work onto a Worker Pool. It is the fundamental <em><b>scheduler</b></em> of work onto the CPU. It creates and consumes <a class="el" href="classgts_1_1_task.html">Tasks</a> as a fundamental unit of work. A Micro-scheduler is always mapped to a Worker Pool with a 1:1 mapping between Local Schedulers and Workers.</p>
<h2><a class="anchor" id="autotoc_md75"></a>
Terminology</h2>
<ul>
<li><b>Local Scheduler:</b> A per Worker scheduling element that schedules work onto a Worker and coordinates with other Local Schedulers.</li>
<li><b>Local Scheduler ID:</b> An OwnedId of a Local Scheduler, where the Owner ID is the ID of the Micro-scheduler and the Local ID is the ID of the Local Scheduler.</li>
<li><b>Master:</b> The Local Scheduler associated with the calling thread that creates the Micro-scheduler. The Master will not schedule work unless the developer calls a wait function on the Micro-scheduler, however other Local Schedulers can take work from it. It always has a local ID of 0. Further, GTS does not require that a Micro-scheduler and Worker Pool share the same Master thread.</li>
<li><b>Task:</b> A task is the unit of work that the Micro-scheduler consumes. Tasks are dynamically managed by the Micro-scheduler and enable <a href="https://en.wikipedia.org/wiki/Fork%E2%80%93join_model">fork-join</a> parallelism. It is important to note that Tasks are not persistent. Tasks are generally destroyed once they are executed. See (dev_guide_micro_fork_join) for details on using Tasks. (For persistent work items, use the Macro-scheduler's Nodes.)</li>
<li><b>Isolation:</b> GTS has no limits on the number of Micro-schedulers that can be attached to a Worker Pool. All Micro-schedulers are executed in round-robin order, and each Micro-scheduler is a separate execution arena, meaning its Tasks are isolated from other Micro-scheduler's Tasks.</li>
<li><b>External Victim:</b> Micro-schedulers can reference other Micro-schedulers as External Victims. Tasks are taken from External Victims when all Local Schedulers are exhausted of Tasks. This</li>
</ul>
<table style="width:100%">
<tr>
<td style="text-align:center; padding-right:60px"><img src="MicroSchedulerMapping_IDs.svg" alt="" style="pointer-events: none;" class="inline"/> </td><td style="text-align:center; padding-right:60px"><img src="MicroSchedulerMapping_IDs_2.svg" alt="" style="pointer-events: none;" class="inline"/>  </td></tr>
<tr>
<td class="tableCaption" style="text-align:center">Fig 1. Same Master as its Worker Pool. </td><td class="tableCaption" style="text-align:center">Fig 2. Different Master thread than its Worker Pool. Local Scheduler 0 will not be utilized.  </td></tr>
<tr>
<td style="text-align:center"><img src="Isolation.svg" alt="" style="pointer-events: none;" class="inline"/> </td><td style="text-align:center"><img src="ExternalVictim.svg" alt="" style="pointer-events: none;" class="inline"/>  </td></tr>
<tr>
<td class="tableCaption" style="text-align:center">Fig 3. Isolation of Mutliple Schedulers </td><td class="tableCaption" style="text-align:center">Fig 4. External Victim  </td></tr>
</table>
<dl class="section warning"><dt>Warning</dt><dd>Shutting down a Worker Pool will implicity destroy all attached Micro-schedulers.</dd></dl>
<h2><a class="anchor" id="autotoc_md76"></a>
Initialization</h2>
<p>A Micro-scheduler can be initialized two ways: with just a Worker Pool, or with a description structure.</p>
<h3><a class="anchor" id="autotoc_md77"></a>
Basic</h3>
<div class="fragment"><div class="line"><a class="code" href="classgts_1_1_worker_pool.html">gts::WorkerPool</a> workerPool;</div>
<div class="line">workerPool.<a class="code" href="classgts_1_1_worker_pool.html#a0a210a25fa82f85cab05a28552b6fdbf">initialize</a>();</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classgts_1_1_micro_scheduler.html">gts::MicroScheduler</a> taskScheduler;</div>
<div class="line">taskScheduler.<a class="code" href="classgts_1_1_micro_scheduler.html#a91203e6e2ebb2866381adbde8876bebb">initialize</a>(&amp;workerPool);</div>
</div><!-- fragment --><h3><a class="anchor" id="dev_guide_micro_desc"></a>
Description Structure</h3>
<p>The Micro-scheduler can further be initialized explicity with a <a class="el" href="structgts_1_1_micro_scheduler_desc.html">description structure</a>, specifying Task priorities and debugging info.</p>
<ul>
<li><b>Task Priority:</b> Task priority imparts an ordering on Task execution within a Local Scheduler. Priorities are indexed [0, priorityCount), with zero being the highest priority. Task priorities are not preemptive, that is if a Task is spawned with higher priority than the currently executing, it will have to wait until the currently executing task finishes. To prevent starvation, a boost age is used to temporarily boost lower priority Tasks.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classgts_1_1_worker_pool.html">gts::WorkerPool</a> workerPool;</div>
<div class="line">workerPool.<a class="code" href="classgts_1_1_worker_pool.html#a0a210a25fa82f85cab05a28552b6fdbf">initialize</a>();</div>
<div class="line"> </div>
<div class="line">MicroSchedulerDesc schedulerDesc;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the WorkerPool to run on.</span></div>
<div class="line">schedulerDesc.pWorkerPool = &amp;workerPool;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the number of Task priorities.</span></div>
<div class="line"><span class="comment">// Priorities are indexed [0, priorityCount), with zero being the highest</span></div>
<div class="line"><span class="comment">// priority. Must be &gt;= 1;</span></div>
<div class="line">schedulerDesc.priorityCount = 1;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the age for each Worker when a lower priority Task will try to be</span></div>
<div class="line"><span class="comment">// executed. Age is measured in number of Task executions since the last</span></div>
<div class="line"><span class="comment">// boost.</span></div>
<div class="line">schedulerDesc.priorityBoostAge = 1000;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set a name to aid in debugging.</span></div>
<div class="line">sprintf(schedulerDesc.name, <span class="stringliteral">&quot;TheMicroScheduler&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classgts_1_1_micro_scheduler.html">gts::MicroScheduler</a> microScheduler;</div>
<div class="line">microScheduler.<a class="code" href="classgts_1_1_micro_scheduler.html#a91203e6e2ebb2866381adbde8876bebb">initialize</a>(&amp;workerPool);</div>
</div><!-- fragment --><h1><a class="anchor" id="dev_guide_tut_micro_init_examples"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md78"></a>
1-1 Affinity</h2>
<p>This example shows how to create a Worker Pool with a 1-1 SW thread to HW thread relationship.</p>
<p><img src="1to1Affinity.svg" alt="" style="pointer-events: none;" class="inline"/>   </p>
<p><a class="el" href="2__1to1__affinity__init_8h_source.html">Example Code</a></p>
<h2><a class="anchor" id="dev_guide_priority_init"></a>
Preemptive Task Priority</h2>
<p>This example shows how to use two Worker Pools and Micro-schedulers to create preemptive priorities among Tasks. The GTS Micro-schedule implements Task priorities, yet it does not context switch when a higher priority task is spawned. To achieve context switching behavior, one needs to use the OS's preemptive scheduler.</p>
<p><img src="PreemptivePriorities.svg" alt="" style="pointer-events: none;" class="inline"/>   </p>
<p><a class="el" href="3__priority__init_8h_source.html">Example Code</a></p>
<h2><a class="anchor" id="autotoc_md79"></a>
Task Isolation</h2>
<p>This example shows how to use two Mirco-scheduler to create two regions of Task isolation.</p>
<p><img src="Isolation.svg" alt="" style="pointer-events: none;" class="inline"/>   </p>
<p><a class="el" href="4__isolation__init_8h_source.html">Example Code</a></p>
<h2><a class="anchor" id="autotoc_md80"></a>
Partitioning</h2>
<p>This example demonstrates processor partitioning using the following hypothetical:</p>
<p>Imagine a scenario where there are long-running, multi-frame Tasks that need to run alongside a normal update loop. If the long-running Tasks are mixed with the update-loop, the update-loop Tasks could starve. To handle this quality-of-service issue, processors can be partitioned into two WorkerPools, one to handle the update-loop Tasks and one to handle the long-running Tasks. The goal of this configuration is to keep Tasks isolated. The only time it may be ok to break this isolation is when the long-running Micro-scheduler is out of Tasks, where it can victimize the update-loop Tasks.</p>
<p><img src="Partition.svg" alt="" style="pointer-events: none;" class="inline"/>   </p>
<p><a class="el" href="5__partition__init_8h_source.html">Example Code</a></p>
<dl class="section note"><dt>Note</dt><dd>One could also solve this problem similar to the (<a class="el" href="dev_guide_prog_mod_micro_init.html#dev_guide_priority_init">Preemptive Task Priority</a>) example with the update loop running higher priority; however, issues could arise with cache thrashing when the tasks are context switched.</dd></dl>
<h2><a class="anchor" id="autotoc_md81"></a>
NUMA Hierarchy</h2>
<p>This example demonstrates hierarchical Task scheduling over two NUMA nodes. Each node gets it's own Worker Pool and Micro-scheduler. The goal of this configuration is to keep Tasks local to each NUMA node as long as possible. Only when they run out of Tasks do they communicate with each other through victimization.</p>
<p><img src="NumaHierarchy.svg" alt="" style="pointer-events: none;" class="inline"/>   </p>
<p><a class="el" href="2__1to1__affinity__init_8h_source.html">Example Code</a></p>
<h2><a class="anchor" id="autotoc_md82"></a>
Heterogenous Hierarchy</h2>
<p>This example demonstrates hierarchical Task scheduling over two Efficiency Classes. Each Efficiency class gets it's own Worker Pool and Micro-scheduler. The goal of this configuration is to keep Tasks local to their Efficiency Class as long as possible. The only non-local communication that happens is when the more efficient Micro-scheduler victimizes the less efficient Micro-scheduler. Victimization is one-way, because we don't want a more computationally intensive Task to run on a less efficient processor, which could dramatically increase the overall <a href="https://en.wikipedia.org/wiki/Makespan">makespan</a> of the schedule.</p>
<p><img src="EfficiencyClass.svg" alt="" style="pointer-events: none;" class="inline"/>   </p>
<p><a class="el" href="2__1to1__affinity__init_8h_source.html">Example Code</a></p>
<p><br  />
 <br  />
 <br  />
 <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="aclassgts_1_1_worker_pool_html_a0a210a25fa82f85cab05a28552b6fdbf"><div class="ttname"><a href="classgts_1_1_worker_pool.html#a0a210a25fa82f85cab05a28552b6fdbf">gts::WorkerPool::initialize</a></div><div class="ttdeci">bool initialize(uint32_t threadCount=0)</div></div>
<div class="ttc" id="astructgts_1_1_worker_pool_desc_html"><div class="ttname"><a href="structgts_1_1_worker_pool_desc.html">gts::WorkerPoolDesc</a></div><div class="ttdoc">The description of a WorkerPool.</div><div class="ttdef"><b>Definition:</b> MicroSchedulerTypes.h:172</div></div>
<div class="ttc" id="aclassgts_1_1_micro_scheduler_html"><div class="ttname"><a href="classgts_1_1_micro_scheduler.html">gts::MicroScheduler</a></div><div class="ttdoc">A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.</div><div class="ttdef"><b>Definition:</b> MicroScheduler.h:104</div></div>
<div class="ttc" id="astructgts_1_1_worker_pool_desc_html_a6238c64768e4ba2da9c97c108127a15c"><div class="ttname"><a href="structgts_1_1_worker_pool_desc.html#a6238c64768e4ba2da9c97c108127a15c">gts::WorkerPoolDesc::pVisitor</a></div><div class="ttdeci">WorkerPoolVisitor * pVisitor</div><div class="ttdoc">A user-defined visitor object for the WorkerPool. The object must stay alive for the lifetime of the ...</div><div class="ttdef"><b>Definition:</b> MicroSchedulerTypes.h:205</div></div>
<div class="ttc" id="aclassgts_1_1_micro_scheduler_html_a91203e6e2ebb2866381adbde8876bebb"><div class="ttname"><a href="classgts_1_1_micro_scheduler.html#a91203e6e2ebb2866381adbde8876bebb">gts::MicroScheduler::initialize</a></div><div class="ttdeci">bool initialize(WorkerPool *pWorkerPool)</div><div class="ttdoc">Initializes the MicroScheduler and attaches it to pWorkPool, where each worker in pWorkPool will exec...</div></div>
<div class="ttc" id="astructgts_1_1_worker_pool_desc_html_a4f6290f534d1fd6567b8c74f56eadd4f"><div class="ttname"><a href="structgts_1_1_worker_pool_desc.html#a4f6290f534d1fd6567b8c74f56eadd4f">gts::WorkerPoolDesc::workerDescs</a></div><div class="ttdeci">gts::Vector&lt; WorkerThreadDesc &gt; workerDescs</div><div class="ttdoc">The description of each worker thread.</div><div class="ttdef"><b>Definition:</b> MicroSchedulerTypes.h:184</div></div>
<div class="ttc" id="astructgts_1_1_worker_pool_desc_html_a7342f26da50f534d9341220566cd5021"><div class="ttname"><a href="structgts_1_1_worker_pool_desc.html#a7342f26da50f534d9341220566cd5021">gts::WorkerPoolDesc::name</a></div><div class="ttdeci">char name[DESC_NAME_SIZE]</div><div class="ttdoc">A name to help with debugging.</div><div class="ttdef"><b>Definition:</b> MicroSchedulerTypes.h:224</div></div>
<div class="ttc" id="astructgts_1_1_worker_pool_desc_html_a2f260a1f805f95d7adceda5b739cebf8"><div class="ttname"><a href="structgts_1_1_worker_pool_desc.html#a2f260a1f805f95d7adceda5b739cebf8">gts::WorkerPoolDesc::initialTaskCountPerWorker</a></div><div class="ttdeci">uint32_t initialTaskCountPerWorker</div><div class="ttdoc">The number of Tasks to create and cache per Worker during initialization.</div><div class="ttdef"><b>Definition:</b> MicroSchedulerTypes.h:218</div></div>
<div class="ttc" id="astructgts_1_1_this_thread_html_a94073c4c59603a010d35a5d19ead1a1e"><div class="ttname"><a href="structgts_1_1_this_thread.html#a94073c4c59603a010d35a5d19ead1a1e">gts::ThisThread::setName</a></div><div class="ttdeci">static GTS_INLINE void setName(const char *name)</div><div class="ttdoc">Sets the name of the thread.</div><div class="ttdef"><b>Definition:</b> Thread.h:510</div></div>
<div class="ttc" id="astructgts_1_1_worker_thread_desc_html_a2ba1ba4aa956b3054dacb2c1e3bc8d0e"><div class="ttname"><a href="structgts_1_1_worker_thread_desc.html#a2ba1ba4aa956b3054dacb2c1e3bc8d0e">gts::WorkerThreadDesc::name</a></div><div class="ttdeci">char name[DESC_NAME_SIZE]</div><div class="ttdoc">The thread's name.</div><div class="ttdef"><b>Definition:</b> MicroSchedulerTypes.h:132</div></div>
<div class="ttc" id="astructgts_1_1_worker_pool_desc_html_a6ddc0570ed13670518c3a7ccce832feb"><div class="ttname"><a href="structgts_1_1_worker_pool_desc.html#a6ddc0570ed13670518c3a7ccce832feb">gts::WorkerPoolDesc::cachableTaskSize</a></div><div class="ttdeci">uint32_t cachableTaskSize</div><div class="ttdoc">The maximum size of Tasks that are cached and reused. Sizes larger than this will be allocated from t...</div><div class="ttdef"><b>Definition:</b> MicroSchedulerTypes.h:212</div></div>
<div class="ttc" id="aclassgts_1_1_thread_html_a62e240cb86d364cb0c3bc941917479df"><div class="ttname"><a href="classgts_1_1_thread.html#a62e240cb86d364cb0c3bc941917479df">gts::Thread::getHardwareThreadCount</a></div><div class="ttdeci">static GTS_INLINE uint32_t getHardwareThreadCount()</div><div class="ttdoc">Gets the number of logical processor on this system.</div><div class="ttdef"><b>Definition:</b> Thread.h:466</div></div>
<div class="ttc" id="astructgts_1_1_system_topology_html"><div class="ttname"><a href="structgts_1_1_system_topology.html">gts::SystemTopology</a></div><div class="ttdoc">A description of the system's processor topology.</div><div class="ttdef"><b>Definition:</b> Thread.h:251</div></div>
<div class="ttc" id="aclassgts_1_1_thread_html_a91888c263187754ac797711ecbf334a7"><div class="ttname"><a href="classgts_1_1_thread.html#a91888c263187754ac797711ecbf334a7">gts::Thread::getSystemTopology</a></div><div class="ttdeci">static GTS_INLINE void getSystemTopology(SystemTopology &amp;out)</div><div class="ttdoc">Gets the topology of all the processors in the system.</div><div class="ttdef"><b>Definition:</b> Thread.h:460</div></div>
<div class="ttc" id="astructgts_1_1_worker_thread_desc_html"><div class="ttname"><a href="structgts_1_1_worker_thread_desc.html">gts::WorkerThreadDesc</a></div><div class="ttdoc">The description of a worker Thread.</div><div class="ttdef"><b>Definition:</b> MicroSchedulerTypes.h:87</div></div>
<div class="ttc" id="aclassgts_1_1_worker_pool_html"><div class="ttname"><a href="classgts_1_1_worker_pool.html">gts::WorkerPool</a></div><div class="ttdoc">A collection of running Worker threads that a MicroScheduler can be run on.</div><div class="ttdef"><b>Definition:</b> WorkerPool.h:74</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
