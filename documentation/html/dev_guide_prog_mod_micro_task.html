<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Games Task Scheduler (GTS): Micro-scheduler Task Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Games Task Scheduler (GTS)
   </div>
   <div id="projectbrief">A multi-processor scheduling framework for games engines</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dev_guide_prog_mod_micro_task.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Micro-scheduler Task Interface </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section covers the Micro-scheduler's low-level Task interface. It is the interface used to build all the <a class="el" href="group___parallel_patterns.html">Parallel Patterns</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The Task interface is for low-level, high performance algorithm design. It is recommended to only use this interface if there is not an available Parallel Pattern. For a thorough understanding of the pitfalls, please read this entire section especial (<a class="el" href="dev_guide_prog_mod_micro_task.html#dev_guide_pitfalls">Pitfalls</a>).</dd></dl>
<h1><a class="anchor" id="autotoc_md81"></a>
Tasks</h1>
<p>In GTS a Task is modeled by the <a class="el" href="classgts_1_1_task.html">Task</a> class. Tasks can be syntactically represented in three ways:</p>
<ul>
<li><b>By Subclassing Task</b></li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// The extended Task class.</span></div>
<div class="line"><span class="keyword">struct </span>IncTask : <span class="keyword">public</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a></div>
<div class="line">{</div>
<div class="line">    IncTask(<span class="keywordtype">int</span>&amp; v) : val(v) {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Override execute to define your work.</span></div>
<div class="line">    <span class="keyword">virtual</span> Task* execute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp;) <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">        ++val;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// The value to increment.</span></div>
<div class="line"><span class="keywordtype">int</span> val = 3;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the Task.</span></div>
<div class="line"><a class="code" href="classgts_1_1_task.html">gts::Task</a>* pTask = microScheduler.<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>&lt;IncTask&gt;(val);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Spawn it with a Micro-scheduler and wait for it to complete.</span></div>
<div class="line">microScheduler.<a class="code" href="classgts_1_1_micro_scheduler.html#a132adf759619130d7bbca9e0cdc07d83">spawnTaskAndWait</a>(pTask);</div>
<div class="line"><a class="code" href="group___assert.html#ga11827364e7df1f266e03e40cd0f0eab2">GTS_ASSERT</a>(val == 4);</div>
</div><!-- fragment --><ul>
<li><b>By use of Lambdas</b></li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// The value to increment.</span></div>
<div class="line"><span class="keywordtype">int</span> val = 3;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the Task with a lambda.</span></div>
<div class="line"><a class="code" href="classgts_1_1_task.html">gts::Task</a>* pTask = microScheduler.<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([&amp;val](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp;)</div>
<div class="line">{</div>
<div class="line">    ++val;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Spawn it with a Micro-scheduler and wait for it to complete.</span></div>
<div class="line">microScheduler.<a class="code" href="classgts_1_1_micro_scheduler.html#a132adf759619130d7bbca9e0cdc07d83">spawnTaskAndWait</a>(pTask);</div>
<div class="line"><a class="code" href="group___assert.html#ga11827364e7df1f266e03e40cd0f0eab2">GTS_ASSERT</a>(val == 4);</div>
</div><!-- fragment --><ul>
<li><b>By use of C-style functions</b></li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// The Task function.</span></div>
<div class="line"><a class="code" href="classgts_1_1_task.html">gts::Task</a>* incrementFunction(<span class="keywordtype">void</span>* pData, <a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span>&amp; val = *(<span class="keywordtype">int</span>*)pData;</div>
<div class="line">    ++val;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// The value to increment.</span></div>
<div class="line"><span class="keywordtype">int</span> val = 3;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the Task with a function and pointer.</span></div>
<div class="line"><a class="code" href="classgts_1_1_task.html">gts::Task</a>* pTask = microScheduler.<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>&lt;CStyleTask&gt;(incrementFunction, &amp;val);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Spawn it with a Micro-scheduler and wait for it to complete.</span></div>
<div class="line">microScheduler.<a class="code" href="classgts_1_1_micro_scheduler.html#a132adf759619130d7bbca9e0cdc07d83">spawnTaskAndWait</a>(pTask);</div>
<div class="line"><a class="code" href="group___assert.html#ga11827364e7df1f266e03e40cd0f0eab2">GTS_ASSERT</a>(val == 4);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Much of the Task interface for GTS is inspired by TBB. If you already know TBB, GTS will be familiar to you.</dd></dl>
<h2><a class="anchor" id="autotoc_md82"></a>
Activation Frame</h2>
<p>The activation frame of a Task is the <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">gts::Task</a> execute method. It is were a Task's work is done, and it is where dependenies can be dynaimcally added to executing Task.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md83"></a>
Task Context</h3>
<p>The <a class="el" href="structgts_1_1_task_context.html" title="The context associated with the task being executed.">gts::TaskContext</a> is a parameter that is passed into the activation frame. It contains contextual information about the Task like</p><ul>
<li>The Task itself, which is useful for labmda Task</li>
<li>A reference to the Micro-scheduler that created the Task, which is needed for added dependecies.</li>
<li>A OwnedId of the Worker thread executing the Task, which is useful for binning resources.</li>
</ul>
<h3><a class="anchor" id="autotoc_md84"></a>
Return Task</h3>
<p>The Task returned from the Activation Frame is executed immediately, completely bypassing the scheduler. We'll see how to used this as an optimization <a class="el" href="dev_guide_prog_mod_micro_task.html#task_bypassing">later</a>.</p>
<h2><a class="anchor" id="autotoc_md85"></a>
Spawning</h2>
<ul>
<li><b>Fire-and-forget:</b> Spawns a Task that does not need to be waited on for completion. <div class="fragment"><div class="line"><a class="code" href="classgts_1_1_task.html">gts::Task</a>* pTask = microScheduler.<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">microScheduler.<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pTask);</div>
</div><!-- fragment --></li>
<li><b>Fire-and-wait:</b> Spawns a Task and waits for it to complete. <div class="fragment"><div class="line"><a class="code" href="classgts_1_1_task.html">gts::Task</a>* pTask = microScheduler.<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">microScheduler.<a class="code" href="classgts_1_1_micro_scheduler.html#a132adf759619130d7bbca9e0cdc07d83">spawnTaskAndWait</a>(pTask);</div>
</div><!-- fragment --></li>
<li><b>Affinity:</b> Forces a Task to run on a specific Worker thread. It must be set before spawning. <div class="fragment"><div class="line"><span class="comment">// Let&#39;s say we only want to run this Task on Worker thread 3</span></div>
<div class="line"><span class="comment">// of the WorkerPool attached to the Micro-scheduler.</span></div>
<div class="line">pTask-&gt;<a class="code" href="classgts_1_1_task.html#a7665332c06028e3bc97c826a563caac3">setAffinity</a>(3);</div>
<div class="line"><span class="comment">// Now this Task can only every be run on Worker thread 3.</span></div>
</div><!-- fragment --></li>
<li><b>Priority:</b> Spawns a Task the specified <a class="el" href="dev_guide_prog_mod_micro_init.html#dev_guide_micro_desc">Task priority</a>. <div class="fragment"><div class="line">uin32_t priority = 2</div>
<div class="line">microScheduler.<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pTask, priority);</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md86"></a>
Lifetime</h2>
<p>Task are dynamic, reference counted objects. They are created by a Micro-scheduler with a reference count of one and they lose a reference when executed. If their reference count becomes zero after execution, they are destroyed.</p>
<div class="fragment"><div class="line">microScheduler.<a class="code" href="classgts_1_1_micro_scheduler.html#a132adf759619130d7bbca9e0cdc07d83">spawnTaskAndWait</a>(pTask);</div>
<div class="line">pTask-&gt;doSomething(); <span class="comment">// Error! pTask no longer exists after execution.</span></div>
</div><!-- fragment --><p>Later we'll explore how to manipulate the reference count.</p>
<h2><a class="anchor" id="autotoc_md87"></a>
Dependencies</h2>
<p>Task dependencies are modeled by making a Task a child of another Task, or by making a Task a continuation of another Task.</p>
<h3><a class="anchor" id="autotoc_md88"></a>
Children</h3>
<p>Child Tasks model forks. Children refer to their parent Task directly, and a parent Task refers to its children in reference count only. When a child Task has finished executing, it decrements its parent’s reference count.</p>
<p><img src="ChildTask.svg" alt="" style="pointer-events: none;" class="inline"/>   </p>
<p>The safest way to add a child is with a reference count, as it automatically adds the reference to the parent.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    addChildWithRef(pChild);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild); <span class="comment">// fork.</span></div>
<div class="line">    ...</div>
</div><!-- fragment --><p>Yet, this can be inefficient when adding multiple children. In this case, it is better to manually adjust the reference count and then add the children without reference increment</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// If the child count is known up-front, we can added the references without incuring an</span></div>
<div class="line">    <span class="comment">// expensive XADD per child.</span></div>
<div class="line">    addRef(2, memory_order::relaxed);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild1 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    addChildWithoutRef(pChild1);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild1);</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild2 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    addChildWithoutRef(pChild2);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild2);</div>
<div class="line">    ...</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Forgetting to add reference counts will cause undefined behavior.</dd></dl>
<h3><a class="anchor" id="autotoc_md89"></a>
Continuations</h3>
<p>Continuations are Tasks that join two or more child Tasks. The child Tasks refer directly to the continuation and the continuation Task refers to its children in reference count only. When creating a continuation, the current Task is unlinked from the task graph and the continuation in link in its place.</p>
<p><img src="ContinuationTask.svg" alt="" style="pointer-events: none;" class="inline"/>   </p>
<p>When a child finishes executing, it decrements its continuations’s reference count. If the reference count is one, meaning that it is the last child, it executes the continuation.</p>
<p>Here is an example of inserting a continuation Task into a Task graph.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pContinuation = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    setContinuation(pContinuation);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We now add the children to the continuation, so increase its ref count.</span></div>
<div class="line">    pContinuation-&gt;<a class="code" href="classgts_1_1_task.html#aa5b4870753c61b5921d0656abd58ad41">addRef</a>(2, memory_order::relaxed);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild1 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    pContinuation-&gt;addChildWithoutRef(pChild1);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild1);</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild2 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    pContinuation-&gt;addChildWithoutRef(pChild2);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild2);</div>
<div class="line">    ...</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Forgetting to add reference counts will cause undefined behavior.</dd></dl>
<h1><a class="anchor" id="autotoc_md90"></a>
Joining</h1>
<p>GTS offer two options for joins: blocking joins and continuations.</p>
<h2><a class="anchor" id="autotoc_md91"></a>
Blocking</h2>
<p>Blocking joins are joins that wait for a Task to complete. Blocking joins block the current execution stream, however they do not block the executing thread. Instead the executing thread executes work in the Micro-scheduler.</p>
<dl class="section note"><dt>Note</dt><dd>Blocking joins are the simplest form of joining in the Task model, yet they can also introduce the most latency. The latency comes from executing Tasks in the Micro-scheduler while waiting, which can cause the blocked execution stream to not immediately resume when ready.</dd></dl>
<p>Here is an example of blocking with <a class="el" href="classgts_1_1_task.html#afad495099ad194958daf16dbd5c93a32">gts::Task::waitForAll</a>. Note the extra reference count added for the wait. /(This is done to distinguish a waiting parent from a waiting continuation./) </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Add references for the children plus 1 for the wait.</span></div>
<div class="line">    addRef(2 + 1, memory_order::relaxed);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild1 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    addChildWithoutRef(pChild1);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild1);</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild2 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    addChildWithoutRef(pChild2);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild2);</div>
<div class="line">    </div>
<div class="line">    waitForAll(); <span class="comment">// blocking join.</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// do more stuff ...</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We can also used gts::Task::spwandWaitForAll, which combines spawning and blocking. It is slightly more efficient for the last child Task. </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Add references for the children plus 1 for the wait.</span></div>
<div class="line">    addRef(2 + 1, memory_order::relaxed);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild1 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    addChildWithoutRef(pChild1);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild1);</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild2 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    addChildWithoutRef(pChild2);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Combines spawning and blocking. Slightly more efficient for the last Task.</span></div>
<div class="line">    spawnTaskAndWaitForAll(pChild2);<span class="comment">// blocking join.</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// do more stuff ...</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md92"></a>
Continuations</h2>
<p>Continuations are explicit join Tasks that execute immediately when their dependencies have completed. Generally, continuations do not suffer the latency of blocking joins, but they do require explicit linking into a Task graph.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pContinuation = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    setContinuation(pContinuation);</div>
<div class="line"> </div>
<div class="line">    pContinuation-&gt;<a class="code" href="classgts_1_1_task.html#aa5b4870753c61b5921d0656abd58ad41">addRef</a>(2, memory_order::relaxed);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild1 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    pContinuation-&gt;addChildWithoutRef(pChild1);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild1);</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild2 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    pContinuation-&gt;addChildWithoutRef(pChild2);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild2);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// No waiting. The last child executed will execute the continuation.</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md93"></a>
Optimizations</h2>
<h3><a class="anchor" id="task_bypassing"></a>
Bypassing</h3>
<p>Bypassing is an optimization where a Task is returned from the activation frame instead of being spawned. It is an optimization because the returned Task is executed immediately instead of being store and retrieved from from the Micro-scheduler’s internal Task storage. Bypassing with a child Tasks requires the use of continuations becuase there is no longer an option of waiting. Bypassing fire-and-forget Tasks have no constraints.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pContinuation = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    setContinuation(pContinuation);</div>
<div class="line">    </div>
<div class="line">    pContinuation-&gt;<a class="code" href="classgts_1_1_task.html#aa5b4870753c61b5921d0656abd58ad41">addRef</a>(2, memory_order::relaxed);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild1 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    pContinuation-&gt;addChildWithoutRef(pChild1);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild1);</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild2 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    pContinuation-&gt;addChildWithoutRef(pChild2);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Return the Task instead of spawning to bypass the scheduler.</span></div>
<div class="line">    <span class="comment">//ctx.pMicroScheduler-&gt;spawnTask(pChild2);</span></div>
<div class="line">    <span class="keywordflow">return</span> pChild2;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md94"></a>
Task Recycling</h3>
<p>Task recycling is an optimization that reuses the currently executing Task as a new Tasks. Once the current Task finished excuting it is not destroyed and instead treaded as a newly spawned Task.</p>
<p>Here are the safe ways to recycle a Task:</p>
<ul>
<li><b>As a child with bypassing</b>: <div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pContinuation = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    setContinuation(pContinuation);</div>
<div class="line"> </div>
<div class="line">    pContinuation-&gt;<a class="code" href="classgts_1_1_task.html#aa5b4870753c61b5921d0656abd58ad41">addRef</a>(2, memory_order::relaxed);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild1 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    pContinuation-&gt;addChildWithoutRef(pChild1);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild1);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Recyle this Task instead of spawning a new one.</span></div>
<div class="line">    <span class="comment">//gts::Task* pChild2 = ctx.pMicroScheduler-&gt;allocateTask([](gts::TaskContext const&amp; ctx) { ... });</span></div>
<div class="line">    <span class="comment">//pContinuation-&gt;addChildWithoutRef(pChild2);</span></div>
<div class="line">    <span class="comment">//ctx.pMicroScheduler-&gt;spawnTask(pChild2);</span></div>
<div class="line">    recyleAsChildOf(pContinuationTask);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Reset some data on this Task...</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>As a continuation</b>: <div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    recycle();</div>
<div class="line">    setContinuation(<span class="keyword">this</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We now add the children to the continuation, so increase its ref count.</span></div>
<div class="line">    addRef(2, memory_order::relaxed);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild1 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    pContinuation-&gt;addChildWithoutRef(pChild1);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild1);</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild2 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    pContinuation-&gt;addChildWithoutRef(pChild2);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Return the Task instead of spawning to bypass the scheduler.</span></div>
<div class="line">    <span class="comment">//ctx.pMicroScheduler-&gt;spawnTask(pChild2);</span></div>
<div class="line">    <span class="keywordflow">return</span> pChild2;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>As automatic fire-and-forget</b>: <div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// This task will be respawned once this function returns.</span></div>
<div class="line">    recycle();</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>As bypass fire-and-forget</b>: <div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// This task will be executed immediately once this function returns.</span></div>
<div class="line">    recycle();</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md95"></a>
Full Examples</h2>
<ol type="1">
<li><a class="el" href="2__blocking__join_8h_source.html">Blocking</a></li>
<li><a class="el" href="3__continuation__join_8h_source.html">Continuations</a></li>
<li><a class="el" href="4__scheduler__bypassing_8h_source.html">Bypassing</a></li>
<li><a class="el" href="5__task__recycling_8h_source.html">Recycling</a></li>
</ol>
<h1><a class="anchor" id="autotoc_md96"></a>
General Task Graphs</h1>
<p>The following examples demonstrate the creation of <a class="el" href="dev_guide_prog_mod_terminology.html#dev_guide_online_sched_cat">weakly dynamic</a> and <a class="el" href="dev_guide_prog_mod_terminology.html#dev_guide_online_sched_cat">strongly dynamic</a> graphs in GTS. The examples create graphs for a 2D prefix sum using a naïve wavefront algorithm.</p>
<p><img src="Wavefront.svg" alt="" style="pointer-events: none;" class="inline"/>   </p>
<dl class="section note"><dt>Note</dt><dd>Examples of static Task graphs are omitted because execution time is not considered in the Micro-scheduler’s greedy scheduling algorithm.</dd></dl>
<h2><a class="anchor" id="autotoc_md97"></a>
Weakly Dynamic Task Graph</h2>
<p>This <a class="el" href="6__weakly__dynamic__task__graph__wavefront_8h_source.html">example</a> prebuilds a Task graph and then executes its. It also demonstrates manipulating a root Task's reference count.</p>
<h2><a class="anchor" id="autotoc_md98"></a>
Strongly Dynamic Task Graph</h2>
<p>This <a class="el" href="7__strongly__dynamic__task__graph__wavefront_8h_source.html">example</a> generates the graph as the execution unfolds. It moves the data out of the Tasks and into a memoization table. It does not require special treatment if the last Task like the previous example did. Further, it is more efficient since parallelizes the creation of the graph.</p>
<dl class="section note"><dt>Note</dt><dd>GTS includes a production version of a wavefront algorithm <a class="el" href="classgts_1_1_parallel_wavefront.html" title="A construct that maps parallel-wavefront behavior to a MicroScheduler.">gts::ParallelWavefront</a>.</dd></dl>
<h1><a class="anchor" id="dev_guide_pitfalls"></a>
Pitfalls</h1>
<p>This section will cover various race condition that can occur when setting up dependencies</p>
<h2><a class="anchor" id="autotoc_md99"></a>
Accessing a Spawned Task</h2>
<div class="fragment"><div class="line">microScheduler.spawn(pTask);</div>
<div class="line">pTask-&gt;doSomething(); <span class="comment">// Race condition! pTask may or may not be executed and destroyed.</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md100"></a>
Children and Reference Counting</h2>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild1 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild1);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild2 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild2);</div>
<div class="line"> </div>
<div class="line">    waitForAll(); Undefined! No references were added <span class="keywordflow">for</span> the children.</div>
<div class="line">    ...</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md101"></a>
Blocking and Reference Counting</h2>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild1 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    addChildWithRef(pChild1);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild1);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild2 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    addChildWithRef(pChild2);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild2);</div>
<div class="line"> </div>
<div class="line">    waitForAll(); Undefined! No reference was added to <span class="keyword">this</span> task <span class="keywordflow">for</span> the wait.</div>
<div class="line">    ...</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md102"></a>
Continuations and Reference Counting</h2>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classgts_1_1_task.html">gts::Task</a>* myExecute(<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) <span class="keyword">final</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pContinuation = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    setContinuation(pContinuation);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Undefined! No references were added for the continuation&#39;s children.</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild1 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    pContinuation-&gt;addChildWithoutRef(pChild1);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild1);</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pChild2 = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line">    pContinuation-&gt;addChildWithoutRef(pChild2);</div>
<div class="line">    ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a>(pChild2);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md103"></a>
Blocking and Stack Overflow</h2>
<div class="fragment"><div class="line"><a class="code" href="classgts_1_1_task.html">gts::Task</a>* stackOverflowTask(TaskContext <span class="keyword">const</span>&amp; ctx)</div>
<div class="line">{</div>
<div class="line">    addRef(2, memory_order::relaxed);</div>
<div class="line">    <a class="code" href="classgts_1_1_task.html">gts::Task</a>* pTask = ctx.pMicroScheduler-&gt;allocateTask(taskFunc);</div>
<div class="line">    addChildWithoutRef(pTask);</div>
<div class="line">    ctx.pMicroScheduler-&gt;spawnTask(pTask);</div>
<div class="line">    waitForAll();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md104"></a>
Cycles</h2>
<div class="fragment"><div class="line"><a class="code" href="classgts_1_1_task.html">gts::Task</a>* pTaskA = ctx.pMicroScheduler-&gt;allocateTask([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line"><a class="code" href="classgts_1_1_task.html">gts::Task</a>* pTaskB = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line"><a class="code" href="classgts_1_1_task.html">gts::Task</a>* pTaskC = ctx.<a class="code" href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">pMicroScheduler</a>-&gt;<a class="code" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a>([](<a class="code" href="structgts_1_1_task_context.html">gts::TaskContext</a> <span class="keyword">const</span>&amp; ctx) { ... });</div>
<div class="line"> </div>
<div class="line">pTaskA-&gt;addChildWithRef(pTaskB);</div>
<div class="line">pTaskB-&gt;addChildWithRef(pTaskC);</div>
<div class="line">pTaskC-&gt;addChildWithRef(pTaskA);</div>
<div class="line"> </div>
<div class="line">Undefined! Cyclic graph.</div>
<div class="line">ctx.pMicroScheduler-&gt;spawnTaskAndWait(pTaskA);</div>
</div><!-- fragment --><p><br  />
 <br  />
 <br  />
 <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="astructgts_1_1_task_context_html_a8fb42f128c5e6df118c6c3e25369b5c8"><div class="ttname"><a href="structgts_1_1_task_context.html#a8fb42f128c5e6df118c6c3e25369b5c8">gts::TaskContext::pMicroScheduler</a></div><div class="ttdeci">MicroScheduler * pMicroScheduler</div><div class="ttdoc">The MicroScheduler executing the Task.</div><div class="ttdef"><b>Definition:</b> MicroSchedulerTypes.h:60</div></div>
<div class="ttc" id="agroup___assert_html_ga11827364e7df1f266e03e40cd0f0eab2"><div class="ttname"><a href="group___assert.html#ga11827364e7df1f266e03e40cd0f0eab2">GTS_ASSERT</a></div><div class="ttdeci">#define GTS_ASSERT(expr)</div><div class="ttdoc">Causes execution to break when expr is false.</div><div class="ttdef"><b>Definition:</b> Assert.h:159</div></div>
<div class="ttc" id="aclassgts_1_1_task_html_aa5b4870753c61b5921d0656abd58ad41"><div class="ttname"><a href="classgts_1_1_task.html#aa5b4870753c61b5921d0656abd58ad41">gts::Task::addRef</a></div><div class="ttdeci">GTS_INLINE int32_t addRef(int32_t count=1, gts::memory_order order=gts::memory_order::seq_cst)</div><div class="ttdef"><b>Definition:</b> Task.inl:84</div></div>
<div class="ttc" id="aclassgts_1_1_task_html_a7665332c06028e3bc97c826a563caac3"><div class="ttname"><a href="classgts_1_1_task.html#a7665332c06028e3bc97c826a563caac3">gts::Task::setAffinity</a></div><div class="ttdeci">GTS_INLINE void setAffinity(uint32_t workerIdx)</div><div class="ttdef"><b>Definition:</b> Task.inl:78</div></div>
<div class="ttc" id="aclassgts_1_1_micro_scheduler_html_a132adf759619130d7bbca9e0cdc07d83"><div class="ttname"><a href="classgts_1_1_micro_scheduler.html#a132adf759619130d7bbca9e0cdc07d83">gts::MicroScheduler::spawnTaskAndWait</a></div><div class="ttdeci">void spawnTaskAndWait(Task *pTask, uint32_t priority=0)</div><div class="ttdoc">Spawns the specified 'pTask' to be executed by the scheduler and then waits for its reference count t...</div></div>
<div class="ttc" id="aclassgts_1_1_micro_scheduler_html_afa24e7a258e9bc879200050400d72bb9"><div class="ttname"><a href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">gts::MicroScheduler::allocateTask</a></div><div class="ttdeci">GTS_INLINE TTask * allocateTask(TArgs &amp;&amp;... args)</div><div class="ttdoc">Allocates a new Task object of type TTask.</div><div class="ttdef"><b>Definition:</b> MicroScheduler.h:168</div></div>
<div class="ttc" id="aclassgts_1_1_task_html"><div class="ttname"><a href="classgts_1_1_task.html">gts::Task</a></div><div class="ttdoc">A Task payload that embeds TFunc and TArgs into the Task's data. It makes it easy to construct a Task...</div><div class="ttdef"><b>Definition:</b> Task.h:149</div></div>
<div class="ttc" id="astructgts_1_1_task_context_html"><div class="ttname"><a href="structgts_1_1_task_context.html">gts::TaskContext</a></div><div class="ttdoc">The context associated with the task being executed.</div><div class="ttdef"><b>Definition:</b> MicroSchedulerTypes.h:55</div></div>
<div class="ttc" id="aclassgts_1_1_micro_scheduler_html_a8ee931d6d19602004705231c5beb8243"><div class="ttname"><a href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">gts::MicroScheduler::spawnTask</a></div><div class="ttdeci">void spawnTask(Task *pTask, uint32_t priority=0)</div><div class="ttdoc">Spawns the specified 'pTask' to be executed by the scheduler. Spawned tasks are executed in LIFO orde...</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
