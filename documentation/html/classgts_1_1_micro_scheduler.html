<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Games Task Scheduler (GTS): gts::MicroScheduler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Games Task Scheduler (GTS)
   </div>
   <div id="projectbrief">A multi-processor scheduling framework for games engines</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classgts_1_1_micro_scheduler.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classgts_1_1_micro_scheduler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gts::MicroScheduler Class Reference<div class="ingroups"><a class="el" href="group___micro_scheduler.html">MicroScheduler</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A work-stealing task scheduler. The scheduler is executed by the <a class="el" href="classgts_1_1_worker_pool.html" title="A collection of running Worker threads that a MicroScheduler can be run on.">WorkerPool</a> it is initialized with.  
 <a href="classgts_1_1_micro_scheduler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_micro_scheduler_8h_source.html">MicroScheduler.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adcf02fd39749bd1a1480e7ad3d9a9ffa"><td class="memItemLeft" align="right" valign="top"><a id="adcf02fd39749bd1a1480e7ad3d9a9ffa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#adcf02fd39749bd1a1480e7ad3d9a9ffa">MicroScheduler</a> ()</td></tr>
<tr class="memdesc:adcf02fd39749bd1a1480e7ad3d9a9ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> in an uninitialized state. The user must call <a class="el" href="classgts_1_1_micro_scheduler.html#a91203e6e2ebb2866381adbde8876bebb" title="Initializes the MicroScheduler and attaches it to pWorkPool, where each worker in pWorkPool will exec...">MicroScheduler::initialize</a> to initialize the scheduler before use, otherwise calls to this <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> are undefined. <br /></td></tr>
<tr class="separator:adcf02fd39749bd1a1480e7ad3d9a9ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0160de7ef79d5bc486f732ffbeecad"><td class="memItemLeft" align="right" valign="top"><a id="a3d0160de7ef79d5bc486f732ffbeecad"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a3d0160de7ef79d5bc486f732ffbeecad">~MicroScheduler</a> ()</td></tr>
<tr class="memdesc:a3d0160de7ef79d5bc486f732ffbeecad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicitly shuts down the <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> if it's still running. <br /></td></tr>
<tr class="separator:a3d0160de7ef79d5bc486f732ffbeecad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1333502c73baf62bd867b5a3fe6a25de"><td class="memItemLeft" align="right" valign="top"><a id="a1333502c73baf62bd867b5a3fe6a25de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MicroScheduler</b> (<a class="el" href="classgts_1_1_micro_scheduler.html">MicroScheduler</a> const &amp;)=delete</td></tr>
<tr class="separator:a1333502c73baf62bd867b5a3fe6a25de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13b527f0d3ac0e6d6311b2599ebd04e"><td class="memItemLeft" align="right" valign="top"><a id="ab13b527f0d3ac0e6d6311b2599ebd04e"></a>
<a class="el" href="classgts_1_1_micro_scheduler.html">MicroScheduler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classgts_1_1_micro_scheduler.html">MicroScheduler</a> const &amp;)=delete</td></tr>
<tr class="separator:ab13b527f0d3ac0e6d6311b2599ebd04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91203e6e2ebb2866381adbde8876bebb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a91203e6e2ebb2866381adbde8876bebb">initialize</a> (<a class="el" href="classgts_1_1_worker_pool.html">WorkerPool</a> *pWorkerPool)</td></tr>
<tr class="memdesc:a91203e6e2ebb2866381adbde8876bebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> and attaches it to <em>pWorkPool</em>, where each worker in pWorkPool will execute submitted tasks.  <a href="classgts_1_1_micro_scheduler.html#a91203e6e2ebb2866381adbde8876bebb">More...</a><br /></td></tr>
<tr class="separator:a91203e6e2ebb2866381adbde8876bebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1aa6c03b6dfd3465a5821cac30640e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a4b1aa6c03b6dfd3465a5821cac30640e">initialize</a> (<a class="el" href="structgts_1_1_micro_scheduler_desc.html">MicroSchedulerDesc</a> const &amp;desc)</td></tr>
<tr class="memdesc:a4b1aa6c03b6dfd3465a5821cac30640e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> for use. It creates the worker thread pool and allocates all memory to meet the requirements in <em>desc</em>.  <a href="classgts_1_1_micro_scheduler.html#a4b1aa6c03b6dfd3465a5821cac30640e">More...</a><br /></td></tr>
<tr class="separator:a4b1aa6c03b6dfd3465a5821cac30640e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5eeb538581d25ec5354dffc9e03b18f"><td class="memItemLeft" align="right" valign="top"><a id="ac5eeb538581d25ec5354dffc9e03b18f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#ac5eeb538581d25ec5354dffc9e03b18f">shutdown</a> ()</td></tr>
<tr class="memdesc:ac5eeb538581d25ec5354dffc9e03b18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> and destroys all resources. The TaskSchuduler is now in an unusable state. All subsequent calls to this <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> are undefined. <br /></td></tr>
<tr class="separator:ac5eeb538581d25ec5354dffc9e03b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa24e7a258e9bc879200050400d72bb9"><td class="memTemplParams" colspan="2">template&lt;typename TTask , typename... TArgs&gt; </td></tr>
<tr class="memitem:afa24e7a258e9bc879200050400d72bb9"><td class="memTemplItemLeft" align="right" valign="top">GTS_INLINE TTask *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">allocateTask</a> (TArgs &amp;&amp;... args)</td></tr>
<tr class="memdesc:afa24e7a258e9bc879200050400d72bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a> object of type TTask.  <a href="classgts_1_1_micro_scheduler.html#afa24e7a258e9bc879200050400d72bb9">More...</a><br /></td></tr>
<tr class="separator:afa24e7a258e9bc879200050400d72bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab60269532f283c552cea2e2bb54cb66"><td class="memTemplParams" colspan="2">template&lt;typename TFunc , typename... TArgs&gt; </td></tr>
<tr class="memitem:aab60269532f283c552cea2e2bb54cb66"><td class="memTemplItemLeft" align="right" valign="top">GTS_INLINE <a class="el" href="classgts_1_1_task.html">Task</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#aab60269532f283c552cea2e2bb54cb66">allocateTask</a> (TFunc &amp;&amp;func, TArgs &amp;&amp;... args)</td></tr>
<tr class="memdesc:aab60269532f283c552cea2e2bb54cb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a> object and emplaces the function/lambda data.  <a href="classgts_1_1_micro_scheduler.html#aab60269532f283c552cea2e2bb54cb66">More...</a><br /></td></tr>
<tr class="separator:aab60269532f283c552cea2e2bb54cb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee931d6d19602004705231c5beb8243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">spawnTask</a> (<a class="el" href="classgts_1_1_task.html">Task</a> *pTask, uint32_t priority=0)</td></tr>
<tr class="memdesc:a8ee931d6d19602004705231c5beb8243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns the specified 'pTask' to be executed by the scheduler. Spawned tasks are executed in LIFO order, and stolen in FIFO order.  <a href="classgts_1_1_micro_scheduler.html#a8ee931d6d19602004705231c5beb8243">More...</a><br /></td></tr>
<tr class="separator:a8ee931d6d19602004705231c5beb8243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132adf759619130d7bbca9e0cdc07d83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a132adf759619130d7bbca9e0cdc07d83">spawnTaskAndWait</a> (<a class="el" href="classgts_1_1_task.html">Task</a> *pTask, uint32_t priority=0)</td></tr>
<tr class="memdesc:a132adf759619130d7bbca9e0cdc07d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns the specified 'pTask' to be executed by the scheduler and then waits for its reference count to become one.  <a href="classgts_1_1_micro_scheduler.html#a132adf759619130d7bbca9e0cdc07d83">More...</a><br /></td></tr>
<tr class="separator:a132adf759619130d7bbca9e0cdc07d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce3bfc3ac0f2918bfcf6c4b5dbf0f1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#adce3bfc3ac0f2918bfcf6c4b5dbf0f1a">waitFor</a> (<a class="el" href="classgts_1_1_task.html">Task</a> *pTask)</td></tr>
<tr class="memdesc:adce3bfc3ac0f2918bfcf6c4b5dbf0f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for pTask's reference count to become one.  <a href="classgts_1_1_micro_scheduler.html#adce3bfc3ac0f2918bfcf6c4b5dbf0f1a">More...</a><br /></td></tr>
<tr class="separator:adce3bfc3ac0f2918bfcf6c4b5dbf0f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bc08e660c6890aab49a40e4557815c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a38bc08e660c6890aab49a40e4557815c">waitForAll</a> ()</td></tr>
<tr class="memdesc:a38bc08e660c6890aab49a40e4557815c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for this <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> to have executed all it's tasks.  <a href="classgts_1_1_micro_scheduler.html#a38bc08e660c6890aab49a40e4557815c">More...</a><br /></td></tr>
<tr class="separator:a38bc08e660c6890aab49a40e4557815c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86bc5fb63f9322033155f8e8f68b366"><td class="memItemLeft" align="right" valign="top"><a id="ac86bc5fb63f9322033155f8e8f68b366"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#ac86bc5fb63f9322033155f8e8f68b366">destoryTask</a> (<a class="el" href="classgts_1_1_task.html">Task</a> *pTask)</td></tr>
<tr class="memdesc:ac86bc5fb63f9322033155f8e8f68b366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually destroy pTask. Undefined if this <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a> is executing. <br /></td></tr>
<tr class="separator:ac86bc5fb63f9322033155f8e8f68b366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21d53e557bfeef2bdce780656f8760a"><td class="memItemLeft" align="right" valign="top">GTS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#ac21d53e557bfeef2bdce780656f8760a">setActiveState</a> (bool <a class="el" href="classgts_1_1_micro_scheduler.html#a075238071e878e9872101df5df94f6eb">isActive</a>)</td></tr>
<tr class="memdesc:ac21d53e557bfeef2bdce780656f8760a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the active state of this <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a>. An active <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> will be run by the <a class="el" href="classgts_1_1_worker_pool.html" title="A collection of running Worker threads that a MicroScheduler can be run on.">WorkerPool</a> and a inactive <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> will be ignored. By default, an initialized <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> is active.  <a href="classgts_1_1_micro_scheduler.html#ac21d53e557bfeef2bdce780656f8760a">More...</a><br /></td></tr>
<tr class="separator:ac21d53e557bfeef2bdce780656f8760a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf38be6a898a3965e2c24f5f896a63d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#aaf38be6a898a3965e2c24f5f896a63d0">addExternalVictim</a> (<a class="el" href="classgts_1_1_micro_scheduler.html">MicroScheduler</a> *pScheduler)</td></tr>
<tr class="memdesc:aaf38be6a898a3965e2c24f5f896a63d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 'pScheduler' as an external victim. All Schedules in this <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> will be able to steal from pScheduler when they run out of work.  <a href="classgts_1_1_micro_scheduler.html#aaf38be6a898a3965e2c24f5f896a63d0">More...</a><br /></td></tr>
<tr class="separator:aaf38be6a898a3965e2c24f5f896a63d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5999ec6f2fe560408340261d12d375de"><td class="memItemLeft" align="right" valign="top"><a id="a5999ec6f2fe560408340261d12d375de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a5999ec6f2fe560408340261d12d375de">removeExternalVictim</a> (<a class="el" href="classgts_1_1_micro_scheduler.html">MicroScheduler</a> *pScheduler)</td></tr>
<tr class="memdesc:a5999ec6f2fe560408340261d12d375de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes 'pScheduler' as an external victim. <br /></td></tr>
<tr class="separator:a5999ec6f2fe560408340261d12d375de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88af507e44b044df45bb04cb7b17b020"><td class="memTemplParams" colspan="2">template&lt;typename TFunc &gt; </td></tr>
<tr class="memitem:a88af507e44b044df45bb04cb7b17b020"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a88af507e44b044df45bb04cb7b17b020">registerCallback</a> (MicroSchedulerCallbackType type, TFunc callback, void *pUserData)</td></tr>
<tr class="separator:a88af507e44b044df45bb04cb7b17b020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278584ce90fcdd5714a505a6fd75b184"><td class="memTemplParams" colspan="2">template&lt;typename TFunc &gt; </td></tr>
<tr class="memitem:a278584ce90fcdd5714a505a6fd75b184"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a278584ce90fcdd5714a505a6fd75b184">unregisterCallback</a> (MicroSchedulerCallbackType type, TFunc callback, void *pUserData)</td></tr>
<tr class="separator:a278584ce90fcdd5714a505a6fd75b184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0cf1c9a0a5f83f078452dffdd795ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#aee0cf1c9a0a5f83f078452dffdd795ea">isRunning</a> () const</td></tr>
<tr class="memdesc:aee0cf1c9a0a5f83f078452dffdd795ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the scheduler is running.  <a href="classgts_1_1_micro_scheduler.html#aee0cf1c9a0a5f83f078452dffdd795ea">More...</a><br /></td></tr>
<tr class="separator:aee0cf1c9a0a5f83f078452dffdd795ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3fa6b82e67cc7533497107ce62010d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a2d3fa6b82e67cc7533497107ce62010d">hasTasks</a> () const</td></tr>
<tr class="memdesc:a2d3fa6b82e67cc7533497107ce62010d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the scheduler has tasks.  <a href="classgts_1_1_micro_scheduler.html#a2d3fa6b82e67cc7533497107ce62010d">More...</a><br /></td></tr>
<tr class="separator:a2d3fa6b82e67cc7533497107ce62010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac855a63c3bac8a0a0696d0cfefad652b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#ac855a63c3bac8a0a0696d0cfefad652b">hasExternalTasks</a> () const</td></tr>
<tr class="memdesc:ac855a63c3bac8a0a0696d0cfefad652b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the scheduler has external tasks.  <a href="classgts_1_1_micro_scheduler.html#ac855a63c3bac8a0a0696d0cfefad652b">More...</a><br /></td></tr>
<tr class="separator:ac855a63c3bac8a0a0696d0cfefad652b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd71ea924200bed433b9eb92077c458"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#affd71ea924200bed433b9eb92077c458">workerCount</a> () const</td></tr>
<tr class="memdesc:affd71ea924200bed433b9eb92077c458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the worker count of the <a class="el" href="classgts_1_1_worker_pool.html" title="A collection of running Worker threads that a MicroScheduler can be run on.">WorkerPool</a> this scheduler is attached to.  <a href="classgts_1_1_micro_scheduler.html#affd71ea924200bed433b9eb92077c458">More...</a><br /></td></tr>
<tr class="separator:affd71ea924200bed433b9eb92077c458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5aaa2823e8f45143038239aae7fc94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgts_1_1_owned_id.html">OwnedId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a7b5aaa2823e8f45143038239aae7fc94">thisWorkerId</a> () const</td></tr>
<tr class="memdesc:a7b5aaa2823e8f45143038239aae7fc94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the worker the Worker ID of the calling thread.  <a href="classgts_1_1_micro_scheduler.html#a7b5aaa2823e8f45143038239aae7fc94">More...</a><br /></td></tr>
<tr class="separator:a7b5aaa2823e8f45143038239aae7fc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3393d402bf7a041f0eafc623bb49e7d5"><td class="memItemLeft" align="right" valign="top"><a id="a3393d402bf7a041f0eafc623bb49e7d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a3393d402bf7a041f0eafc623bb49e7d5">wakeWorker</a> ()</td></tr>
<tr class="memdesc:a3393d402bf7a041f0eafc623bb49e7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake a sleeping Worker. <br /></td></tr>
<tr class="separator:a3393d402bf7a041f0eafc623bb49e7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075238071e878e9872101df5df94f6eb"><td class="memItemLeft" align="right" valign="top">GTS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a075238071e878e9872101df5df94f6eb">isActive</a> () const</td></tr>
<tr class="memdesc:a075238071e878e9872101df5df94f6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the scheduler is active.  <a href="classgts_1_1_micro_scheduler.html#a075238071e878e9872101df5df94f6eb">More...</a><br /></td></tr>
<tr class="separator:a075238071e878e9872101df5df94f6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de86496a483939212696b609c560479"><td class="memItemLeft" align="right" valign="top">GTS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a4de86496a483939212696b609c560479">id</a> () const</td></tr>
<tr class="memdesc:a4de86496a483939212696b609c560479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this schedulers ID.  <a href="classgts_1_1_micro_scheduler.html#a4de86496a483939212696b609c560479">More...</a><br /></td></tr>
<tr class="separator:a4de86496a483939212696b609c560479"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a569a99e40e9956672170b1dcbbd01c2c"><td class="memItemLeft" align="right" valign="top"><a id="a569a99e40e9956672170b1dcbbd01c2c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgts_1_1_micro_scheduler.html#a569a99e40e9956672170b1dcbbd01c2c">resetIdGenerator</a> ()</td></tr>
<tr class="memdesc:a569a99e40e9956672170b1dcbbd01c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the ID generator to 0. This is not safe if there are any living MicroSchedulers. <br /></td></tr>
<tr class="separator:a569a99e40e9956672170b1dcbbd01c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aaa7728226b6ce66782e8816b1658dd9a"><td class="memItemLeft" align="right" valign="top"><a id="aaa7728226b6ce66782e8816b1658dd9a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Task</b></td></tr>
<tr class="separator:aaa7728226b6ce66782e8816b1658dd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de4a9533dff2ecc0919852d4c05a67b"><td class="memItemLeft" align="right" valign="top"><a id="a9de4a9533dff2ecc0919852d4c05a67b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Worker</b></td></tr>
<tr class="separator:a9de4a9533dff2ecc0919852d4c05a67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a62e6a4c9b5592382183301a81d305"><td class="memItemLeft" align="right" valign="top"><a id="a41a62e6a4c9b5592382183301a81d305"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>WorkerPool</b></td></tr>
<tr class="separator:a41a62e6a4c9b5592382183301a81d305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27030011b31a7a81dec2eca254d3476"><td class="memItemLeft" align="right" valign="top"><a id="ae27030011b31a7a81dec2eca254d3476"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>LocalScheduler</b></td></tr>
<tr class="separator:ae27030011b31a7a81dec2eca254d3476"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A work-stealing task scheduler. The scheduler is executed by the <a class="el" href="classgts_1_1_worker_pool.html" title="A collection of running Worker threads that a MicroScheduler can be run on.">WorkerPool</a> it is initialized with. </p>
<p>Supports: -Help-first work-stealing -Fork-join with nested parallelism -Supports arbitrary DAGs -Blocking joins -Continuation joins -Scheduler by-passing and task recycling optimizations -<a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a> affinities. (Force a task to run on a specific thread.) -<a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a> priorities with starvation resistance -Scheduler partitioning -<a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a> execution isolation -Hierarchical work-stealing via external victims.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd><p class="startdd">Abstract into interface and make a concrete WorkStealingMicroScheduler. Interface will allow other algorithms to be explored. </p>
<p class="enddd">Explore making priorities global to the scheduler. Currently they are only local to each thread. </p>
</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aaf38be6a898a3965e2c24f5f896a63d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf38be6a898a3965e2c24f5f896a63d0">&#9670;&nbsp;</a></span>addExternalVictim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gts::MicroScheduler::addExternalVictim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgts_1_1_micro_scheduler.html">MicroScheduler</a> *&#160;</td>
          <td class="paramname"><em>pScheduler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds 'pScheduler' as an external victim. All Schedules in this <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> will be able to steal from pScheduler when they run out of work. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This operation can be used to build a graph of MicroSchedulers. However, cycles will cause undefined behavior. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pScheduler</td><td>The victim to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa24e7a258e9bc879200050400d72bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa24e7a258e9bc879200050400d72bb9">&#9670;&nbsp;</a></span>allocateTask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTask , typename... TArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GTS_INLINE TTask* gts::MicroScheduler::allocateTask </td>
          <td>(</td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a> object of type TTask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments for the TTask constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a> or nullptr if the allocation failed. </dd></dl>

</div>
</div>
<a id="aab60269532f283c552cea2e2bb54cb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab60269532f283c552cea2e2bb54cb66">&#9670;&nbsp;</a></span>allocateTask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunc , typename... TArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GTS_INLINE <a class="el" href="classgts_1_1_task.html">Task</a>* gts::MicroScheduler::allocateTask </td>
          <td>(</td>
          <td class="paramtype">TFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a> object and emplaces the function/lambda data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A function that takes args as arguments. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments for func. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a> or nullptr if the allocation failed. </dd></dl>

</div>
</div>
<a id="ac855a63c3bac8a0a0696d0cfefad652b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac855a63c3bac8a0a0696d0cfefad652b">&#9670;&nbsp;</a></span>hasExternalTasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gts::MicroScheduler::hasExternalTasks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the scheduler has external tasks. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there are pending tasks in external victims, false otherwise. </dd></dl>

</div>
</div>
<a id="a2d3fa6b82e67cc7533497107ce62010d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3fa6b82e67cc7533497107ce62010d">&#9670;&nbsp;</a></span>hasTasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gts::MicroScheduler::hasTasks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the scheduler has tasks. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there are pending tasks, false otherwise. </dd></dl>

</div>
</div>
<a id="a4de86496a483939212696b609c560479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de86496a483939212696b609c560479">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GTS_INLINE bool gts::MicroScheduler::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get this schedulers ID. </p>
<dl class="section return"><dt>Returns</dt><dd>The unique ID of the scheduler. </dd></dl>

</div>
</div>
<a id="a4b1aa6c03b6dfd3465a5821cac30640e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1aa6c03b6dfd3465a5821cac30640e">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gts::MicroScheduler::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgts_1_1_micro_scheduler_desc.html">MicroSchedulerDesc</a> const &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> for use. It creates the worker thread pool and allocates all memory to meet the requirements in <em>desc</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>The description of the <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> that describes how to initialize it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the initialization succeeded, false otherwise. </dd></dl>

</div>
</div>
<a id="a91203e6e2ebb2866381adbde8876bebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91203e6e2ebb2866381adbde8876bebb">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gts::MicroScheduler::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgts_1_1_worker_pool.html">WorkerPool</a> *&#160;</td>
          <td class="paramname"><em>pWorkerPool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> and attaches it to <em>pWorkPool</em>, where each worker in pWorkPool will execute submitted tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pWorkerPool</td><td>The <a class="el" href="classgts_1_1_worker_pool.html" title="A collection of running Worker threads that a MicroScheduler can be run on.">WorkerPool</a> to attach to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the initialization succeeded, false otherwise. </dd></dl>

</div>
</div>
<a id="a075238071e878e9872101df5df94f6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075238071e878e9872101df5df94f6eb">&#9670;&nbsp;</a></span>isActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GTS_INLINE bool gts::MicroScheduler::isActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the scheduler is active. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> is active, false otherwise. </dd></dl>

</div>
</div>
<a id="aee0cf1c9a0a5f83f078452dffdd795ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0cf1c9a0a5f83f078452dffdd795ea">&#9670;&nbsp;</a></span>isRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gts::MicroScheduler::isRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the scheduler is running. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the scheduler is running, false otherwise. </dd></dl>

</div>
</div>
<a id="a88af507e44b044df45bb04cb7b17b020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88af507e44b044df45bb04cb7b17b020">&#9670;&nbsp;</a></span>registerCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gts::MicroScheduler::registerCallback </td>
          <td>(</td>
          <td class="paramtype">MicroSchedulerCallbackType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunc&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers a user callback function. </p>

</div>
</div>
<a id="ac21d53e557bfeef2bdce780656f8760a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21d53e557bfeef2bdce780656f8760a">&#9670;&nbsp;</a></span>setActiveState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GTS_INLINE void gts::MicroScheduler::setActiveState </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isActive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the active state of this <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a>. An active <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> will be run by the <a class="el" href="classgts_1_1_worker_pool.html" title="A collection of running Worker threads that a MicroScheduler can be run on.">WorkerPool</a> and a inactive <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> will be ignored. By default, an initialized <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isActive</td><td>True to mark as active. False to mark as inactive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ee931d6d19602004705231c5beb8243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee931d6d19602004705231c5beb8243">&#9670;&nbsp;</a></span>spawnTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gts::MicroScheduler::spawnTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgts_1_1_task.html">Task</a> *&#160;</td>
          <td class="paramname"><em>pTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawns the specified 'pTask' to be executed by the scheduler. Spawned tasks are executed in LIFO order, and stolen in FIFO order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTask</td><td>The <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a> to spawn. It will be destroyed after execution refCount == 1. In the rare situation you want to keep the task alive, add an extra reference. Doing this will require you to call Task::destroy when you are done to avoid memory leaks. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a132adf759619130d7bbca9e0cdc07d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132adf759619130d7bbca9e0cdc07d83">&#9670;&nbsp;</a></span>spawnTaskAndWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gts::MicroScheduler::spawnTaskAndWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgts_1_1_task.html">Task</a> *&#160;</td>
          <td class="paramname"><em>pTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawns the specified 'pTask' to be executed by the scheduler and then waits for its reference count to become one. </p>
<p>There are two blocking behaviors:</p><ol type="1">
<li>If spawnTaskAndWait is called from a worker thread, it will execute other tasks until pTask is complete.</li>
<li>If spawnTaskAndWait is called from a non-worker thread, it will block until pTask is complete.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTask</td><td>The <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a> to spawn. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a>, if queued. Queuing occurs if this function is called on a non-worker thread or if this worker thread has a different affinity that the <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b5aaa2823e8f45143038239aae7fc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5aaa2823e8f45143038239aae7fc94">&#9670;&nbsp;</a></span>thisWorkerId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgts_1_1_owned_id.html">OwnedId</a> gts::MicroScheduler::thisWorkerId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the worker the Worker ID of the calling thread. </p>
<dl class="section return"><dt>Returns</dt><dd>The current Worker ID. </dd></dl>

</div>
</div>
<a id="a278584ce90fcdd5714a505a6fd75b184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278584ce90fcdd5714a505a6fd75b184">&#9670;&nbsp;</a></span>unregisterCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gts::MicroScheduler::unregisterCallback </td>
          <td>(</td>
          <td class="paramtype">MicroSchedulerCallbackType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunc&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unregisters a user callback function. </p>

</div>
</div>
<a id="adce3bfc3ac0f2918bfcf6c4b5dbf0f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce3bfc3ac0f2918bfcf6c4b5dbf0f1a">&#9670;&nbsp;</a></span>waitFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gts::MicroScheduler::waitFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgts_1_1_task.html">Task</a> *&#160;</td>
          <td class="paramname"><em>pTask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for pTask's reference count to become one. </p>
<p>There are two blocking behaviors:</p><ol type="1">
<li>If waitFor is called from a worker thread, it will execute other tasks until pTask is complete.</li>
<li>If waitFor is called from a non-worker thread, it will block until pTask is complete.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTask</td><td>The <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a> to wait on. The <a class="el" href="classgts_1_1_task.html" title="A Task payload that embeds TFunc and TArgs into the Task&#39;s data. It makes it easy to construct a Task...">Task</a> must have an extra reference count for the wait before spawning, otherwise the MicroSchedule will destroy the task on completion. It is also up the the caller to destroy this task once the wait in completed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38bc08e660c6890aab49a40e4557815c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bc08e660c6890aab49a40e4557815c">&#9670;&nbsp;</a></span>waitForAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gts::MicroScheduler::waitForAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for this <a class="el" href="classgts_1_1_micro_scheduler.html" title="A work-stealing task scheduler. The scheduler is executed by the WorkerPool it is initialized with.">MicroScheduler</a> to have executed all it's tasks. </p>
<p>There are two blocking behaviors:</p><ol type="1">
<li>If waitFor is called from a worker thread, it will execute other tasks until complete.</li>
<li>If waitFor is called from a non-worker thread, this function returns immediately. </li>
</ol>

</div>
</div>
<a id="affd71ea924200bed433b9eb92077c458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd71ea924200bed433b9eb92077c458">&#9670;&nbsp;</a></span>workerCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t gts::MicroScheduler::workerCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the worker count of the <a class="el" href="classgts_1_1_worker_pool.html" title="A collection of running Worker threads that a MicroScheduler can be run on.">WorkerPool</a> this scheduler is attached to. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of Workers in the <a class="el" href="classgts_1_1_worker_pool.html" title="A collection of running Worker threads that a MicroScheduler can be run on.">WorkerPool</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>gts</b></li><li class="navelem"><a class="el" href="classgts_1_1_micro_scheduler.html">MicroScheduler</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
